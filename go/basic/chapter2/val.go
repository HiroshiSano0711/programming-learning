package main

import "fmt"

/*
var name type = expression

typeが省略された場合は、型は初期化式によって決まる
= expressionが省略された場合はゼロ値をとる

【ゼロ値】
数値 → 0
ブーリアン → false
文字列 → ""
インターフェースと参照型（スライス、ポインタ、マップ、チャネル、関数） → nil
配列や構造体などの合成型→その全ての要素やフィールドでゼロ値をとる
*/

// ゼロ値の仕組みによって、Goには未初期化の変数というものがない
// 例：エラーや予期しない振る舞いを起こすのではなく空文字列を表示する
func main() {
	var s string
	fmt.Println(s)
}

/*
単一宣言で複数の変数を宣言できる
*/
var i, j, k int                 // int, int, int
var b, f, s = true, 2.3, "four" // bool, float64, string

// パッケージレベルの変数はmainが始まる前に初期化される。ローカル変数は関数の実行中に宣言に出会った時に初期化される
// 多値を返す関数を呼び出すことで、変数の集まりを初期化することもできる
// var f, err = os.Open(name) // os.Openはファイルとエラーを返す

/*
【省略変数宣言】
関数内でローカル変数を宣言して初期化するためにつかえる形式。

name := expression
nameの型はexpressionの型で決まる。

簡潔で柔軟なこともあって、ローカル変数の大多数が省略変数宣言をつかわれる

var宣言が使われる場合
・ローカル変数の型が初期化子式と異なるため明示的な型を必要する場合
・後で値が代入されて変数の初期値が重要でないような場合

複数の変数を同じように初期化できるけど可読性が向上する場合に使った方がよい
i, j := 0, 1

:=は宣言であり=は代入であることに注意
i, j = j, i // iとjの値を交換する

2つ以上の値を返す関数の呼び出しに対して使える
f, err := os.Open(name)
if err != nil {
	return err
}
f.Close()

同じレキシカルブロック内で宣言されていた場合は代入のように働く
f, err := os.Open(name)
out, err := os.Create(outfile) // errへは代入になる

しかし少なくとも1つ以上の新しい変数を宣言しなければならない
f, err := os.Open(name)
f, err := os.Create(outfile) // コンパイルエラー、新たな変数がない

*/
