// Listing9-1.S
// 第9章からはありとあらゆる変換を扱う。
//

#include "aoaa.inc"

// 1バイト（8ビット）の値を、2文字の16進ASCII文字列に変換する関数
proc    btoh_simple 

    // 下位8bitだけマスクして取り出す
    // 例：x1 = 0x0000_0000_0000_00AF
    // nibble(4bit/半バイト)をLOとHOで分けてそれぞれ１文字とする
    and     x1, x1, #0xFF
    mov     x0, x1

    // この段階でのレジスタの状態
    // x1 = 0xAF   （上位ニブルを処理する予定）
    // x0 = 0xAF   （下位ニブルを処理する予定）

    // lsr = logical shift right(右シフト命令)
    // x1の値（0xAF = 1010 1111）を 4ビット右シフト。
    // 結果： 0xAF >> 4 = 0x0A
    // 上位ニブル（A）が下位ニブルの位置に落ちてくる。
    // x1 = 0x0A

    lsr     x1, x1, #4

    // '0' は文字コードで0x30
    // 16進数はそれぞれ
    // 0〜9 → '0'〜'9' (0x30〜0x39)
    // 10〜15 → 'A'〜'F' (0x41〜0x46)
    // が対応している。
    // 0x0〜0x9 に OR 0x30 → 0x30〜0x39（ASCII の '0'〜'9'）
    orr     x1, x1, #'0'

    // '0'~'9'の文字列はそのままでOKだからそのままジャンプ
    cmp     x1, #'9'
    bls     le9as

    // 0xA~0xFは、7を足して補正してから次の処理へ。
    // A~F（10~15）は
    //   orr     x1, x1, #'0'
    // の処理を行うと0x3A~0x3Fになる。
    // 0x3A + 7 = 0x41 → 'A'
    // 0x3B + 7 = 0x42 → 'B'
    // 0x3C + 7 = 0x43 → 'C'
    // 0x3D + 7 = 0x44 → 'D'
    // 0x3E + 7 = 0x45 → 'E'
    // 0x3F + 7 = 0x46 → 'F'
    add     x1, x1, #7

le9as:
    // HOは処理したので今度はLOニブルの処理
    // 処理の流れは上のHOと同じ

    and     x0, x0, #0xF    // HOニブルをマスクで消去
    orr     x0, x0, #'0'    // 0x30から0x3Fの値へ変換
    cmp     x0, #'9'        // 0x3Aから0x3Fの間でないかチェック
    bls     le9bs 
    add     x0, x0, #7      // A~Fなら7を足して補正。
le9bs:
    // ２つのニブルをマージする。
    // 1文字1バイトで表示するから合計2バイトに変換する
    // HO は上位バイト（最初の文字）にして、LO は下位バイト（2文字目）に入れる
    orr     x1, x1, x0, lsl #8 
    ret 
endp    btoh_simple

// 1バイトずつ文字として解釈すれば、2文字として画面や文字列に出力できる。
// もし文字コードの扱いを間違えた場合
// 例えば 16 ビットをそのまま Unicode などに誤解釈すると、1文字扱いになったり文字化けしたりする。
