// strlen.S
//
// Copyright (C) 2012-2022 Free Software Foundation, Inc.
// This file is part of the GNU C Library. The GNU C
// Library is free software; you can redistribute it
// and/or modify it under the terms of the GNU Lesser
// General Public License as published by the Free
// Software Foundation; either version 2.1 of the License,
// or (at your option) any later version. The GNU C
// Library is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the
// implied warranty of MERCHANTABILITY or FITNESS FOR A
// PARTICULAR PURPOSE. See the GNU Lesser General Public
// License for more details. You should have received a
// copy of the GNU Lesser General Public License along
// with the GNU C Library. If not, see
// <https://www.gnu.org/licenses/>.

#include <sysdep.h>

// Assumptions:
//
// ARMv8-a, AArch64, Advanced SIMD
// MTE compatible

#define srcin       x0
#define result      x0

#define src         x1
#define synd        x2
#define tmp         x3
#define shift       x4

#define data        q0
#define vdata       v0
#define vhas_nul    v1
#define vend        v2
#define dend        d2


// コードを理解できるまで読んだけど非常に難しかった。
// shiftの使い方が天才的
// Neonを使った並列化、圧縮して64bitにパック、ループ判定の効率化、32バイトアラインでの最適化
// などなどテクニック満載のコードで最高でした

STRLEN:
        //---------------------------------------------------------
        // src を 16 バイト境界に切り下げてアラインする
        // ・srcin は元の文字列先頭アドレス
        // ・bic で下位 4bit を削る → 16 の倍数に丸め下げ
        // ・こうすることで ld1 で 16B 読み込んでも
        //   MMU のページ境界をまたがず安全に読み取れる
        //---------------------------------------------------------
        bic     src, srcin, 15


        //---------------------------------------------------------
        // vdata = 16バイト読み込み
        // ・位置は 16B アラインした src
        // ・v0（vdata）に [byte0〜byte15] が入る
        //---------------------------------------------------------
        ld1     {vdata.16b}, [src]


        //---------------------------------------------------------
        // vhas_nul = 各 1バイトが 0 かどうかを比較
        // ・各レーン 8bit → 結果は 0x00 or 0xFF
        // ・NULL 文字（0x00）がある位置は 0xFF になる
        //---------------------------------------------------------
        cmeq    vhas_nul.16b, vdata.16b, 0


        //---------------------------------------------------------
        // shift = (srcin * 4) & 63
        // ・srcin の“16 バイト境界からのズレ(0〜15)”を nibble 単位に変換
        // ・このズレが後で「先頭のゴミデータを消すための右シフト量」になる
        //---------------------------------------------------------
        lsl     shift, srcin, 2


        //---------------------------------------------------------
        // vhas_nul（16b）を 8h(16bit) として扱って右 4bit シフトし
        // 下位 8bit にまとめる → nibble マスク化
        //
        // 結果：16 バイト → 8 バイト（8 個の nibble ペア）
        //
        // 各 nibble は 0xF（= NULL がある）か 0x0（ない）
        //---------------------------------------------------------
        shrn    vend.8b, vhas_nul.8h, 4     /* 128-bit → 64-bit */


        //---------------------------------------------------------
        // vend（v2）の下位 64bit を synd(x2) にビットコピー
        // ・浮動小数点変換ではなく "bit コピー"
        // ・synd は「nibble マスク 64bit 値」
        //---------------------------------------------------------
        fmov    synd, dend


        //---------------------------------------------------------
        // synd >> shift （16B境界のズレ分だけ nibble を右にずらす）
        // ・先頭の「ゴミ領域」の nibble を削り取る
        // ・実際の文字列分だけが synd に残る
        //---------------------------------------------------------
        lsr     synd, synd, shift


        //---------------------------------------------------------
        // synd が 0 → この 16 バイトには NULL が無い
        // → 次の 16 バイトブロックへ進む
        //---------------------------------------------------------
        cbz     synd, zloop


        //---------------------------------------------------------
        // ここに来た時点でこのブロック内に NULL がある
        // synd 中の nibble の何番目が最初の 1 なのか調べる
        //
        // rbit でビット反転（下→上に向けて見やすく）
        // clz で左からゼロの数を数える
        // → 最初の “0xF nibble” の位置 = NULL の byte 位置 * 4bit
        //---------------------------------------------------------
        rbit    synd, synd
        clz     result, synd


        //---------------------------------------------------------
        // nibble 単位 → byte 単位にするため 4 で割る
        //---------------------------------------------------------
        lsr     result, result, 2


        //---------------------------------------------------------
        // これが strlen の返り値（NULL の位置）
        //---------------------------------------------------------
        ret



        //---------------------------------------------------------
        // ここから zloop：大量データ高速処理ループ
        // NULL に当たるまで 16 バイト単位で高速スキャン
        //---------------------------------------------------------
        .p2align 5
zloop:

        //---------------------------------------------------------
        // src += 16 しながら次の 16B を読み込む
        // data = v0 (q0) に入る
        //---------------------------------------------------------
        ldr     data, [src, 16]!


        //---------------------------------------------------------
        // 16 バイトすべてについて「0 == NULL？」比較
        //---------------------------------------------------------
        cmeq    vhas_nul.16b, vdata.16b, 0


        //---------------------------------------------------------
        // umaxp：pairwise max をとる
        // 0x00 / 0xFF の比較なので、どこか 1 つでも 0xFF があれば
        // vend に 0xFF が立ち synd ≠ 0 になる
        //
        // → NULL を含んでいるかどうかだけの高速判定
        //---------------------------------------------------------
        umaxp   vend.16b, vhas_nul.16b, vhas_nul.16b


        //---------------------------------------------------------
        // vend（64bit）を synd へコピー
        //---------------------------------------------------------
        fmov    synd, dend


        //---------------------------------------------------------
        // synd == 0 → この 16B には NULL 無い
        // → 次の 16B を読む
        //---------------------------------------------------------
        cbz     synd, zloop



        //---------------------------------------------------------
        // ここに来たらこの 16B 内に NULL は存在
        // shrn して nibble マスク（8b → 64bit）を作り直す
        //---------------------------------------------------------
        shrn    vend.8b, vhas_nul.8h, 4     /* 128 -> 64 */



        //---------------------------------------------------------
        // result = ここまで進んできたバイト数
        // （src - srcin）で距離を求める
        //---------------------------------------------------------
        sub     result, src, srcin



        //---------------------------------------------------------
        // vend → synd へコピーして nibble マスク取得
        //---------------------------------------------------------
        fmov    synd, dend


        //---------------------------------------------------------
        // rbit + clz で nibble の位置を求める
        //---------------------------------------------------------
        rbit    synd, synd
        clz     tmp, synd



        //---------------------------------------------------------
        // nibble 単位 → byte 単位に変換（lsr 2）
        // それを result に加える
        ----------------------------------------------------------
        add     result, result, tmp, lsr 2



        //---------------------------------------------------------
        // strlen 終了
        //---------------------------------------------------------
        ret
